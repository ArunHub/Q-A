Why Angular?
1. One framework for Mobile/Desktop/Native apps
2. Performance - scrollify
3. SPA
4. Router - manages history objects when pressing back button
5. framework is modular - made every piece of libraries as module. if router not needed, dont import. Unlike java, it dont need JVM mandatory to run.
6. rich data binding - one way two way
7. data transformation - pipes
8. multiple language support[es5,es6,typescript,dart]
9. built-in DI support - no need of creating new objects in constructor
10. compilation - JIT/ AoT
11. Rich animation support
12. http [CRUD]
13. Design applications using modular approach
14. Eager loading / lazy loading
15. change detection cycle [unidirectional - top to bottom]
16. RxJS [reactive extension javascript library]
17. angular - material
18. easy testing [jasmine/karma]
19. Angular elements
20. angular follows component architecture unlike ng1 follows mvp, mvvm, mvc


====================================
codepen 
https://codepen.io/pravinkumarcode/pen/VqqQaa

necessary libraries for angular to create
npm install --save @angular/core @angular/common @angular/compiler @angular/platform-browser @angular/platform-browser-dynamic rxjs zone.js core-js


// CORRECTED
import { Inject } from '@angular/core';

export const WINDOW = new InjectionToken('Window');
export function _window() { return window; }

@Component({
  ...
  providers: [
    { provide: WINDOW, useFactory: _window }
  ]
})
export class MyComponent {
  constructor (@Inject(WINDOW) private win: Window) { ... }
}

===============================================

[attr] which binds to ="value" but simply putting attr= "value" take value as string

@NgModule({
imports: [ CommonModule ],
declarations: [ CustomerComponent, NewItemDirective, OrdersPipe ],
exports: [ CustomerComponent, NewItemDirective, OrdersPipe,
CommonModule, FormsModule ]
})

From <https://angular.io/guide/sharing-ngmodules> 

While using shared module, export the imports also like commonmodule, formsmodule if app module needed.
Normally pipes, directives, components are shared by shared module not service because it creates new instance again and is not typical usage.

====================================================
Reactive Forms

Step 1: Registering the reactive forms modulelink
To use reactive forms, import ReactiveFormsModule from the @angular/forms package and add it to your NgModule's imports array.
Step 2: Generating and importing a new form control
Generate a component for the control.

ng generate component NameEditor
To register a single form control, import the FormControl class into your component and create a new instance of the form control to save as a class property.

export class NameEditorComponent { name = new FormControl(''); }

step 3: Registering the control in the template
For single form control element, [formcontrol] is the syntax. But not in case of grouping form group elements
Grouping form controls
Step 1: Creating a FormGroup instance
Step 2: Associating the FormGroup model and view

Syntax:
<form [formGroup]="profileForm"> <label> First Name: <input type="text" formControlName="firstName"> </label>

[formControl]
[formGroup]
	formControlName
		[formGroup]
			formControlName
formBuilder injector service to reduce repetive formcontrol in multiple forms
Instead of new formGroup, use injected property this.fb.group
	
	 two ways to update the model value:
		• Use the setValue() method to set a new value for an individual control. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control.
		• Use the patchValue() method to replace any properties defined in the object that have changed in the form model.
	
	From <https://angular.io/guide/reactive-forms> 

you use the group() method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.

From <https://angular.io/guide/reactive-forms> 
You can define the control with just the initial value, but if your controls need sync or async validation, add sync and async validators as the second and third items in the array.

From <https://angular.io/guide/reactive-forms> 
==================================================

Hash and path strategy in angular 

Default pathlocation strategy which is based on normal history based api in browser. 
In hash based type, a # will be included in end of domain and the path added after # will be not sent to server.
Like we use in anchor tag <a href="hello">arun</a>
www.domain.com/#hello
When we see network GET request for above link, server neglects after # and parse only www.domain.com
So hash can be programmatically changed and use for bookmarks
While using hash type in routing, from frontend we send only domain alone or server takes domain alone as GET request not other paths after #.
According to the the server there is only ever one URL localhost:4040, the other hash fragment stuff is ignored by the server.
This is why we call what we are building a Single Page Application, there is only ever one page requested from the server. In the above example it’s localhost:4040 — the other pages are just changes to the hash fragment which the client application deals with, from the perspective of the server the whole site is just a single page.

From <https://codecraft.tv/courses/angular/routing/routing-strategies/#_summary> 


In path location type

If we were at localhost:4040/artist

Then we change url using history api and pushstate in ng and go to localhost:4040/artist/123/789
Without sending this url to server, we routes component to another one.

But when we reload the page, this url localhost:4040/artist/123/789 goes to server and GET request for that.

<base href='/my/app'/> is compulsory to tell the root path in index.html

For Angular Universal to work URLs need to be passed to the server side which is why it can only work with a PathLocationStrategy and not a HashLocationStrategy.

From <https://codecraft.tv/courses/angular/routing/routing-strategies/#_summary> 
================================================================

Lazy loading 

three main steps to setting up a lazy loaded feature module:

	• Create the feature module.
	• Create the feature module’s routing module.
	• Configure the routes.

lazy loading syntax uses loadChildren followed by a string that is the relative path to the module, a hash mark or #, and the module’s class name.

	• Arrange imports correctly in appmodule with feature module
	• Use routerlink="/customers" forward slash in front or start with slash
	• Don’t import feature module in app module . Just configure the routes
	• With Just path property , page loads blank without component 
	• If you declare forChild(routes) before forRoot(routes). forRoot will be useless and it will throw error esp in lazy loading. forRoot only use once in root app.
	• For children : give path in routerlink from parent path 
	routerLink="/customers/list"
	• Invalid configuration of route 'customers': children and loadChildren cannot be used together. When lazy loading 'customers' feature module , don’t load children as lazy load module itself.
	{ path: 'customers', loadChildren: './customers/customers.module#CustomersModule' , 
	children: [{
	path: 'orders1', loadChildren: './components/orders/orders.module#OrdersModule'
	}]
	},

	

Cli command for feature module
ng generate module customers --routing

After lazy loading is implemented, I cannot pass value from login lazy module component to root app component or menu component to update username of signed user after autheticated him using jwt from server and changing value from subscribtion area to menu service.
Tried: 
	Menuservice
	Observable
	
	Error : subscribe not found since while initialising menu component, it is not subscribed.
	
	So in this scenario, we can able to use ngrx to rescue to supply data anywhere
	
=================================
html css js
loading each page from server for data
many files -> performance
spa using webpack bundler
seperate ui and js for single page and updating when needed
form module and components
store data in service to make light weight component
use directive on particular element or dom in component or normal dom
pipe to filter some data before rendering
pass data using data binding, service , input output, stream observable subscribe
router
authenticate using canactivate, canactivatechild for child components access
resolve guard to prefetch data before rendering component when you have to wait for data from network call after component initialized
again many files imported in appmodule
so find and seperate feature module and lazy load it
use interceptor to put common headers for request and response
emit data from lazy feature module to parent root component module
	cant use emit data using output since we navigate using router and not using selector 	
	observable didnt work since root component got initialized and it asks for subscribe method which will get undefined. because we depend on auth call to authenticate and send data to root 
-> subject asObservable solves the problem since it can push new values as well as subscribe to it. Not like observable, as we only subscribes to it as REad Only
